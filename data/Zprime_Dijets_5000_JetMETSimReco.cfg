# File: Zprime_Dijets_5000_JetMETSimReco.cfg
# Author: R. Harris
# Date: 5/19/06
#
# JetMET MC Production file for 5000 GeV Z prime decaying to dijets.
# Reconstruction for Jets and MET only.
#
# Configuration to run MC generator followed by GEANT simulation and digitization
# based on  SimG4Core/Application/test/EvtGen+DetSim+Digi.cfg
# tested with CMSSW_0_6_0.
#

process PROD  = {


   service = MessageLogger
   {
      untracked vstring destinations = {"cout"}
      
      vstring categories = { "FwkJob" }

      PSet cout = { PSet default = { int32 limit = 0 }    # kill all messages in the log
                    PSet FwkJob  = { int32 limit = -1 } } # except *all* of FwkJob's	  
      
      untracked vstring fwkJobReports = {"FrameworkJobReport.xml"}
   }

   service = Timing {}


   service = RandomNumberGeneratorService
   {
      untracked uint32 sourceSeed = 135799753
      PSet moduleSeeds =
      {
         untracked uint32 VtxSmeared = 123456789
      }
   }


   # NOTE : if one wants to run with the SiStripDigitizer,
   #        then mag.field in the OscarProducer should be
   #        turned ON; otherwise it gets (re)created by the
   #        SiStripDigitizer, which seems to corrupt at all
   #        the edm::Event record


   # Step 1 : Event Generation
   source = PythiaSource
   {
      untracked int32 maxEvents = 1
      untracked bool pythiaVerbosity = false

      PSet PythiaParameters =
      {

         # This is a vector of ParameterSet names to be read, in this order
         # The first two are in the include files below
         # The last one are simply my additional parameters
     vstring parameterSets =
     {
        "pythiaDefault",
        "myParameters"
     }

         # Default (mostly empty - to keep PYTHIA default) card file
         # Name of the set is "pythiaDefault"
         include "IOMC/GeneratorInterface/test/pythiaDefault.cfg"


         # User cards - name is "myParameters"
     vstring myParameters =
     {

	    'PMAS(32,1)= 5000.            !mass of Zprime',
	    'MSEL=0                      !(D=1) to select between full user control (0, then use MSUB) and some preprogrammed alternative',
	    'MSTP(44) = 3                !only select the Z process',
   	    'MSUB(141) = 1               !ff  gamma z0 Z0',

            'MSTJ(11)=3                 ! Choice of the fragmentation function',
            'MSTJ(22)=2                 !Decay those unstable particles',
            'MSTP(2)=1                  !which order running alphaS',
            'MSTP(33)=0                 !(D=0) inclusion of K factors in (=0: none, i.e. K=1)',
            'MSTP(51)=7                 !structure function chosen',
            'MSTP(81)=1                 !multiple parton interactions 1 is Pythia default',
            'MSTP(82)=4                 !Defines the multi-parton model',
            'MSTU(21)=1                 !Check on possible errors during program execution',
            'PARJ(71)=10.               !for which ctau  10 mm',
            'PARP(82)=1.9               !pt cutoff for multiparton interactions',
            'PARP(89)=1000.             !sqrts for which PARP82 is set',
            'PARP(84)=0.4               !Multiple interactions: matter distribution Registered by Chris.Seez@cern.ch',
            'PARP(90)=0.16              !Multiple interactions: rescaling power Registered by Chris.Seez@cern.ch',
            'PMAS(5,1)=4.2              !mass of b quark',
            'PMAS(6,1)=175.             !mass of top quark',
            'PMAS(23,1)=91.187          !mass of Z',
            'PMAS(24,1)=80.22           !mass of W',

   	    'MDME(289,1)= 1            !d dbar',
   	    'MDME(290,1)= 1            !u ubar',
   	    'MDME(291,1)= 1            !s sbar',
   	    'MDME(292,1)= 1            !c cbar',
   	    'MDME(293,1)= 0            !b bar',
   	    'MDME(294,1)= 0            !t tbar',
   	    'MDME(295,1)= 0            !4th gen Q Qbar',
   	    'MDME(296,1)= 0            !4th gen Q Qbar',
   	    'MDME(297,1)= 0            !e e',
   	    'MDME(298,1)= 0            !neutrino e e',
   	    'MDME(299,1)= 0            ! mu mu',
   	    'MDME(300,1)= 0            !neutrino mu mu',
   	    'MDME(301,1)= 0            !tau tau',
   	    'MDME(302,1)= 0            !neutrino tau tau',
   	    'MDME(303,1)= 0            !4th generation lepton',
   	    'MDME(304,1)= 0            !4th generation neutrino',
   	    'MDME(305,1)= 0            !W W',
   	    'MDME(306,1)= 0            !H  charged higgs',
   	    'MDME(307,1)= 0            !Z',
   	    'MDME(308,1)= 0            !Z',
   	    'MDME(309,1)= 0            !sm higgs',
   	    'MDME(310,1)= 0            !weird neutral higgs HA'
         }

      }
   }

   # event vertex smearing - applies only once (internal check)
   # Note : all internal generatoes will always do (0,0,0) vertex
   #
   module VtxSmeared = VertexGenerator
   {
      string type = "IOMC/EventVertexGenerators/GaussianEventVertexGenerator"
      double MeanX = 0.
      double MeanY = 0.
      double MeanZ = 0.
      double SigmaX = 0.015
      double SigmaY = 0.015
      double SigmaZ = 53.0  // in mm (as in COBRA/OSCAR)
   }

   #Geometry
   #
   include "Geometry/CMSCommonData/data/cmsSimIdealGeometryXML.cfi"
   es_module = TrackerGeometricDetESModule {}

   #Magnetic Field
   #
   include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"

   # Step 2 : CMS Detector Simulation
   # --------------------------------
   # CMS Det.Simulation module (OscarProducer)
   #
   module SimG4Object = OscarProducer
   {
      bool NonBeamEvent = false
      untracked int32 RunNumber = 1001
      untracked int32 G4EventManagerVerbosity = 0
      untracked int32 G4StackManagerVerbosity = 0
      untracked int32 G4TrackingManagerVerbosity = 0
      bool UseMagneticField = true
      # bool UseMagneticField = false
      bool OverrideUserStackingAction = true
      bool StoreRndmSeeds = false
      bool RestoreRndmSeeds = false
      string PhysicsTablesDirectory = "PhysicsTables"
      bool StorePhysicsTables = false
      bool RestorePhysicsTables = false
      #VPSet Watchers = {
      # { string type = "SimTracer"
      #   bool verbose = true }
      #}
      PSet MagneticField =
      {
         double delta = 1.
      }
      PSet Physics =
      {
         # NOTE : if you want EM Physics only,
         #        please select "SimG4Core/Physics/DummyPhysics" for type
         #        and turn ON DummyEMPhysics
         #
         string type = "SimG4Core/Physics/QGSP"
         bool DummyEMPhysics = false
         bool CutsPerRegion = true
         double DefaultCutValue = 1000.  # cuts in cm, i.e. 10m
         untracked int32 Verbosity = 0   # 1 will print cuts as they get set fdrom DD
                                         # 2 will do as 1 + will dump Geant4 table of cuts
      }
      PSet Generator =
      {
         bool ApplyPtCuts = true
         bool ApplyEtaCuts = true
         bool ApplyPhiCuts = false
         double MinPhiCut = 0.   # in degrees,
         double MaxPhiCut = 360. # internally converted to radians, (-pi,pi) range accounted for
         double MinEtaCut = -5.5
         double MaxEtaCut = 5.5
         double MinPtCut = 40.
         double MaxPtCut = 999999.
         untracked int32 Verbosity = 0
      }

      PSet RunAction = { string StopFile = "StopRun" }
      PSet EventAction =
      {
         bool CollapsePrimaryVertices = false
         string StopFile = "StopRun"
         untracked bool debug = false
      }

      PSet TrackingAction =
      {
         untracked bool DetailedTiming = false
      }
      PSet UtilityActions =
      {
               string type = "SimG4Core/UtilityAction/TrackingVerboseAction"
               untracked bool  DEBUG = false
               untracked bool  CheckForHighEtPhotons = false
               untracked int32 EventMin = 0
               untracked int32 EventMax = 0
               untracked int32 EventStep = 1
               untracked int32 TrackMin = 0
               untracked int32 TrackMax = 0
               untracked int32 TrackStep = 1
               untracked int32 VerboseLevel = 0 
      }
      PSet SteppingAction =
      {
         bool   KillBeamPipe = true
         double CriticalEnergyForVacuum = 2.0
#         double CriticalDensity = 1.e-25 is crazy and makes trouble (F.R.)
         double CriticalDensity = 1.e-15
         untracked int32  Verbosity = 0
      }
      PSet TrackerSD =
      {
         bool    ZeroEnergyLoss = false
         bool    NeverAccumulate = false
         bool    PrintHits = false
         double  ElectronicSigmaInNanoSeconds = 12.06
         double  EnergyThresholdForPersistencyInGeV = 0.5
         double  EnergyThresholdForHistoryInGeV = 0.05
      }
      PSet MuonSD =
      {
         double  EnergyThresholdForPersistency = 1.0
         bool    AllMuonsPersistent = false
         bool    PrintHits = false
      }

      PSet CaloSD = {
         double EminTrack = 1.0
         untracked int32  CheckHits = 25
         untracked bool   UseMap = true
         #int32  Verbosity = 1
         untracked int32 Verbosity = 0
         untracked bool   DetailedTiming = false
      }
      PSet ECalSD = {
         bool   UseBirkLaw = false
         double BirkC1 = 0.013
         double BirkC2 = 9.6e-6
         #int32  Verbosity = 11
         int32 Verbosity = 0
      }
      PSet HCalSD = {
         bool   UseBirkLaw = false
         double BirkC1 = 0.013
         double BirkC2 = 9.6e-6
         #int32  Verbosity = 111
         int32 Verbosity = 0
         bool   UseShowerLibrary = true
         bool   TestNumberingScheme = false
      }
      PSet CaloTrkProcessing = {
         #int32  Verbosity = 1
         int32 Verbosity = 0
         bool   TestBeam  = false
         double EminTrack = 0.01
      }
      PSet HFShower =    {
         #int32  Verbosity = 11
         int32 Verbosity = 0
         double ProbMax   = 0.7268
         double CFibre    = 0.50
      }
      PSet HFShowerLibrary = {
         FileInPath FileName = "SimG4CMS/Calo/data/hfshowerlibrary_lhep.root"
         string TreeEMID  = "h3"
         string TreeHadID = "h8"
      }
      PSet HFCherenkov = {
         #int32  Verbosity       = 1
         int32 Verbosity = 0
         double RefIndex        = 1.459
         double Lambda1         = 280.0
         double Lambda2         = 700.0
         double Aperture        = 0.33
         double ApertureTrapped = 0.22
         double Gain            = 0.33
         bool   CheckSurvive    = false
      }
   }  # end of OscarProducer's PSet's/block


   # Step 3 : Digitization of the simulated hits
   #

   # Step 3a : Digitization of the Tracker
   #

   # required for Pixel and SiStrip Digitizers
   #
   es_module = TrackerDigiGeometryESModule {}

   # Pixel's digitization
   #
   include "SimTracker/SiPixelDigitizer/data/PixelDigi.cfi"

   # SiStrip's digitization
   #
   include "SimTracker/SiStripDigitizer/data/SiStripDigi.cfi"

   # Step 3b : Digitization of Ecal and Hcal

   # required for Ecal and Hcal Digitizers
   # NOTE : Both Ecal and Hcal geometries need to be present,
   #        even if only one digitizers is to run
   #
   es_module = EcalPreshowerGeometryEP {}
   es_module = EcalBarrelGeometryEP {}
   es_module = EcalEndcapGeometryEP {}
   es_module = HcalHardcodeGeometryEP {}
   es_module = CaloTowerHardcodeGeometryEP {}
   es_module = CaloGeometryBuilder {}
   es_module = CaloTowerTopologyBuilder {}
   es_module = HcalTopologyIdealEP {}
   es_module = HcalDbProducer {}
   es_source es_hardcode = HcalHardcodeCalibrations
   {
      untracked vstring toGet =
      {
         "Pedestals", "PedestalWidths",
         "Gains", "GainWidths",
         "QIEShape", "QIEData",
         "ChannelQuality", "ElectronicsMap"
      }
   }

   include "SimCalorimetry/EcalSimProducers/data/ecaldigi.cfi"
   
   include "SimCalorimetry/HcalSimProducers/data/hcaldigi.cfi"


   # Step 3c : Muon Digitization


   # this holds CSC geom service, as need for CSC digi's
   # and the digitizer itself
   #
   include "Geometry/CSCGeometry/data/cscGeometry.cfi"
   include "SimMuon/CSCDigitizer/data/muoncscdigi.cfi"

   # Muon DT digi's

   # this holds geom.service as needed by DT digi's
   # and the digitizer itself
   #
   include "Geometry/DTGeometry/data/dtGeometry.cfi"
   include "SimMuon/DTDigitizer/data/muondtdigi.cfi"

   # Mixing Module is *required* to simulated Ecal/Hcal/Muon digitization !

   module mix = MixingModule
   {
#      secsource input = PoolRASource
#      {
         #
         # starting 050, you can skip secsource block at all if you don't
         # wnat to model mixing/pileup at all;
         # however, an at least "empty mixing" need to be present if you
         # want to perform Ecal/Hcal/CSC/DT digitization - those explicitely
         # require presence of CrossingFrame in the edm::Event
         #
         # alternatively, you can set averageNumber=0 if you don't want
         # to model the pileup
         #
         # to the secsource/PoolRASource, you can give just 1 file or more;
         # this files will make a "concatinated buffer", which will go circular
         # until the loop of primary events is done - thus, it'll never run out
         #
         # WARNING: you can only give miltiple files, if they're generated with
         #          identical sets of tracked parameters;
         #          for example, you canNOT give a file made with a single muon
         #          gun and a file made with a single pion gun, because PartID
         #          is a *tracked* parameter in the gun's PSet;
         #          however, you can merge together files made with other generators,
         #          for example, PythiaSource, because all parameters of it would be
         #          *untracked*
         #
#         untracked vstring fileNames =
#         {'file:/afs/cern.ch/cms/geant4rep/genntpl/muon_simhit_for_pileup.060pre1.root' }
#         untracked vstring fileNames =
#         {'file:simevent.root' }
#         string type = "poisson"
#         double averageNumber = 3  # setting this param. to 0 means "No pile-up",
                                   # that is, digitize current crossing only
#         int32 minBunch = -3
#         int32 maxBunch = 5
#         int32 seed = 1234567
#      }
      int32 bunchspace = 25
   }


   #es_source = XMLIdealGeometryESSource 
   #{ 
   #   FileInPath GeometryConfiguration = "Geometry/CMSCommonData/data/simConfiguration.xml"
   #   #the proper root node is set in the xml file
   #   string rootNodeName = ""
   #}




  # include "SimGeneral/HepPDTESSource/data/pdt.cfi"
   es_source = HepPDTESSource {
     string pdtFileName = "/afs/cern.ch/cms/external/lcg/external/HepPDT/2.02.02/slc3_ia32_gcc323/data/PDG_mass_width_2004.mc"
   } 

# this one makes candidates from generator partigles
   module genCandidates = HepMCCandidateProducer {
# pick right source - different for different generators
   	string src = "PythiaSource"
   	# string src = "FlatRandomPtGunSource"
        untracked bool verbose = false
        bool stableOnly = true
    	# vstring excludeList = { "nu(e)0", "nu(mu)0", "nu(tau)0", "mu-", "K(L)0", "n0" }
    	vstring excludeList = { }
  }

#
# Calorimetry
#
###################################################################
 # Get hardcoded conditions the same used for standard digitization
  es_source = EcalTrivialConditionRetriever {
       #untracked double adcToGeVEBConstant = 0.0286
      untracked double adcToGeVEBConstant = 0.0636
  }
 ###################################################################


 #######################################################################################	
 # EB+EE uncalibrated RecHit producer 
 # Weight method (CMS standard requires tuned weights) 	
 include "RecoLocalCalo/EcalRecProducers/data/EcalWeightUncalibratedRecHitProducer.cfi"	
 # Analytic fit (much slower does not require weights) 	
 # include "RecoLocalCalo/EcalRecProducers/data/EcalAnalFitUncalibratedRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
 # EB+EE RecHit producer (from uncalibrated RecHit)
 include "RecoLocalCalo/EcalRecProducers/data/EcalRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
 # ES RecHit producer (from Digis)
 include "RecoLocalCalo/EcalRecProducers/data/ESRecHitProducer.cfi"	
 #######################################################################################


   # HBHE rechit producer
   module recohbhe = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HBHE'
          string digiLabel = 'hcaldigi'
          bool correctForTimeslew = true
   }

   # HO rechit producer
   module recoho = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HO'
          string digiLabel = 'hcaldigi'
          bool correctForTimeslew = true
   }

   # HF rechit producer
   module recohf = HcalSimpleReconstructor {
          int32 firstSample = 2
          int32 samplesToAdd = 2
          string Subdetector = 'HF'
          string digiLabel = 'hcaldigi'
          bool correctForTimeslew = true
   }


# this one makes CaloTowers
   module towermaker = CaloTowersCreator {
      double HBThreshold = 0.9     // GeV, Scheme B
      double HOThreshold = 1.1     // GeV, Scheme B
      double HESThreshold = 1.4    // GeV, Scheme B
      double HEDThreshold = 1.4    // GeV, Scheme B
      double HF1Threshold = 0.5    // GeV, ORCA value
      double HF2Threshold = 0.5    // GeV, ORCA value
      double EBThreshold = 0.09    // GeV, ORCA value w/o selective readout
      double EEThreshold = 0.45    // GeV, ORCA value w/o selective readout
      
      double EBSumThreshold = 0.2  // GeV, Scheme B
      double EESumThreshold = 0.45 // GeV, Scheme B
      double HcalThreshold = -1000 // GeV, -1000 means cut not used 
      double EcutTower = -1000     // GeV, -1000 means cut not used
      double EBWeight = 1.0
      double EEWeight = 1.0
      double HBWeight = 1.0
      double HESWeight = 1.0
      double HEDWeight = 1.0
      double HOWeight = 1.0
      double HF1Weight = 1.0
      double HF2Weight = 1.0
      bool UseHO = true
      string hbheInput = "recohbhe"
      string hoInput = "recoho"
      string hfInput = "recohf"
      vstring ecalInputs = {"ecalrechit/EcalRecHitsEB" }
      untracked bool AllowMissingInputs = true
   }
  
#-------------------
# Jet reconstruction
#-------------------

# this one makes candidates from CaloTowers
   module caloTowers = CaloTowerCandidateCreator {
          string src = "towermaker"
   }
             
   module mcone5 =  MidpointJetProducer {
          untracked int32 debugLevel = 1
          double seedThreshold = 1.0
          double towerThreshold = 0.5
          double coneAreaFraction = 1.0
          int32 maxPairSize = 2
          int32 maxIterations = 100
          double overlapThreshold = .75
          double coneRadius = 0.5
          string src = "caloTowers"
          untracked string jetType = "CaloJet"
   }

   module mcone7 =  MidpointJetProducer {
          untracked int32 debugLevel = 1
          double seedThreshold = 1.0
          double towerThreshold = 0.5
          double coneAreaFraction = 1.0
          int32 maxPairSize = 2
          int32 maxIterations = 100
          double overlapThreshold = .75
          double coneRadius = 0.7
          string src = "caloTowers"
          untracked string jetType = "CaloJet"
   }

   module ktjet =  KtJetProducer {
          int32 ktAngle = 2
          int32 ktRecom = 1
          double ktECut = 1.0
          double ktRParam = 1.0
          string src = "caloTowers"
	  untracked string jetType = "CaloJet"
         }

   module icone5 =  IterativeConeJetProducer {
          string src = "caloTowers"
          untracked int32 debugLevel = 0
          double seedThreshold = 1.0
          double towerThreshold = 0.5
          double coneRadius = 0.5
 	  untracked string jetType = "CaloJet"
        }

   # GenJet parameters same as CaloJet except particle threshold is 0 GeV Et.
   module mcone5gen =  MidpointJetProducer {
          untracked int32 debugLevel = 1
          double seedThreshold = 1.0
          double towerThreshold = 0.0
          double coneAreaFraction = 1.0
          int32 maxPairSize = 2
          int32 maxIterations = 100
          double overlapThreshold = .75
          double coneRadius = 0.5
          string src = "genCandidates"
          untracked string jetType = "GenJet"
   }

   module mcone7gen =  MidpointJetProducer {
          untracked int32 debugLevel = 1
          double seedThreshold = 1.0
          double towerThreshold = 0.0
          double coneAreaFraction = 1.0
          int32 maxPairSize = 2
          int32 maxIterations = 100
          double overlapThreshold = .75
          double coneRadius = 0.7
          string src = "genCandidates"
          untracked string jetType = "GenJet"
   }

   module ktjetgen =  KtJetProducer {
          int32 ktAngle = 2
          int32 ktRecom = 1
          double ktECut = 0.0
          double ktRParam = 1.0
          string src = "genCandidates"
          untracked string jetType = "GenJet"
         }

   module icone5gen =  IterativeConeJetProducer {
          string src = "genCandidates"
          untracked int32 debugLevel = 0
          double seedThreshold = 1.0
          double towerThreshold = 0.0
          double coneRadius = 0.5
 	  untracked string jetType = "GenJet"
        }


#-------------------
# MET reconstruction
#-------------------

  module calomet = METProducer {
         string src = "caloTowers"
        }

  module calometgen = METProducer {
         string src = "genCandidates"
        }

   # Step 4 : Output module
   #
   module GEN-SIM-DIGI = PoolOutputModule
   {
      untracked string fileName = "evtgen_detsim_digi.root"
   }
   module CAL-JETS = PoolOutputModule {
   untracked string fileName = 'evtgen_jets.root'
   untracked vstring outputCommands = 
     {
      "keep *",
      "drop *_muoncscdigi_*_*",
      "drop *_muondtdigi_*_*",
      "drop *_stripdigi_*_*",
      "drop *_pixdigi_*_*",
      "drop *_hcaldigi_*_*",
      "drop *_ecaldigi_*_*",
      "drop *_SimG4Object_*_*"
      }
   } 
   # Now order modules for execution
   #
   sequence trDigi = { pixdigi & stripdigi }
   sequence calDigi = { ecaldigi & hcaldigi }
   sequence muonDigi = { muoncscdigi & muondtdigi }
   sequence doDigi = { trDigi & calDigi & muonDigi  }
   sequence doHReco  = { recohbhe, recoho, recohf }
   sequence doEReco  = { ecaluncalibrechit, ecalrechit }
   sequence doRecoJetMET = {towermaker, caloTowers, mcone5, mcone7, ktjet, icone5, calomet}
   sequence doGenJetMET = {genCandidates, mcone5gen, mcone7gen, ktjetgen, icone5gen, calometgen}
   path p1 = { VtxSmeared, SimG4Object, mix, doDigi, doEReco, doHReco, doGenJetMET, doRecoJetMET}
   endpath outpath = { GEN-SIM-DIGI, CAL-JETS }

}
